# 第六题

## `题目大意`

实现一个带有左、右光标的，可以进行插入、删除、翻转、显示等操作的文本编辑器

## `思路分析`

此题是一个模拟类型的题，对算法的要求并不高
主要思路是：
实现1个带头尾哨兵的双向链表，以及2个光标(每个均带有left、right两个指针)

## `注意事项`

- delete操作：以左光标为例，如果右光标在左光标的右侧相邻1个节点、或重合，那么需要特殊处理(`否则一些pre、nex指针会失效`)

- insert操作：以左光标为例，若开始时左、右光标的状态为重合，那么在结束后，左、右光标的位置`仍应保证重合`

- reverse操作：左、右光标重合 or 左、右光标反序（右光标在左光标的左边）不能进行操作

## `具体实现`

- 读入数据，初始化链表，完成内部指针的连接

- 完善相关的函数：为保证report的简明，具体的实现在此不做赘述，简要说明2个有价值之处：
  - (1). 光标左右分量的引入：解决了因为`翻转`操作带来的`相对`的左(left)、右(right)、前(pre)、后(nex)**混乱**的问题：
    - 代码中的pre、nex没有与字面意思不一定相同
    - 因此在判断真正的左、右时，我们需要借助光标的`左右分量`来判定！以左光标的左、右分量`l、r`为例：若l的nex是r，那么l的`左侧`应该是l的pre；反之则为l的nex
  - (2). 判断两个光标的左右相对位置：
    - 有一个比较便捷的处理方法：引入了一个(int)order，用来记录左、右光标的相对位置。左光标l在右光标r的左侧时，order > 0(且order的值为l、r距离)；order = 0 则重合；order < 0，则为反序
    - 如此一来，我们只需要在光标`移动`、`插入`、`删除`时修改order(++、--、不变)即可。简便、准确地表示左右光标的相对位置

## `时间、空间复杂度分析`

### **时间复杂度**

- $show()$ function: $O(n)$

- 其余: $O(1)$

### **空间复杂度**

- $O(n)$ -- 双向链表

## 总结感悟

- 对于简单但是庞杂的题目，一定要有耐心、信心。这一题我做了近一个星期：每次出现小的问题就重新写，没有耐心仔细想；最后ddl倒数第2天逼得没办法了，于是坚持用一个方法思路，还是能够较快做出来 -- `耐心与信心`

- 指针是个好东西，但是一定要注意指针所指的位置，主要是出现了指向未知内存，或者指针出现环状，则可能会出现re问题、或死循环 -- `指针管理`
