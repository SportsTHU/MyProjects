# 第四题

## `题目大意`

数轴上有n个节点，从i-th节点可以跳到其右侧的区间[$l_i$, $r_i$]，花费t[i]，且n-1个left-right区间的左、右端点分别单调递增，求1-th to n-th的最少时间

## `思路分析`

此目关键思路：区间[ p[i].l, p[i].r ]数轴上从右往左移动（因为随着i的减小，其可以跳到的区间左移）；我们需要得到区间范围内的最小值，用于更新区间源头p[i]的时间代价(区间min + p[i].time)

## `注意事项`

- 双向queue的**empty()**：
  - 应由head、tail的`相对大小`决定，不要惯性思维而简单地`return tail<= 0`
- `初始化非常重要!!`、`一定要注意边界条件!!`
  - 从0到n编号的节点，应该含n+1个：但有时程序的`数组越界`并不会报错！这就会使bug非常难以找到。在日后编程中一定要注意边界、初始化！
  - (这个bug花费2天才得以解决)

- 不同数据printf()的格式要记清，**longlong 用 %d会出问题**

## `具体实现`

- 读入、初始化数据

- 二重循环 + 更新：
  - 外层循环：从最右边开始，向最左边递推
  - 内层循环：分为两部分
    - 第1部分是区间左端点所经过的元素：若此元素element对应的f值(f[element]) <= queue尾部元素；则将队列尾部的元素弹出，直至尾部元素< f[element] or 队列empty()；最后将此元素(element)加入到队列尾部
    - 第2部分是区间右端点所经过的元素：区间右端左移，区间中的元素在减少，queue内一些元素将不再在区间内；判断：如果区间挪出的元素，恰好在队列头部，将其弹出：保证队列中的元素均为当前区间内`存在`的元素
  - 更新：
    - 将区间源头p[i]的时间代价，更新为min{f(element) for element in [ p[i].l, p[i].r ]} + p[i].time

- 论证算法合理性（f[i]的初始化）：
  - 区间[ a[i].l, a[i].r ] 总会在来其源点(a[i])的右端，由此，我们可以得到，每次区间左移，新的区间内元素对应的f[]必然是已被更新过

## `时间、空间复杂度分析`

### **时间复杂度**

- 外层循环：n

- 内层循环：与区间端点变化量有关
  - Left循环：左端点变化量
  - Right循环：右端点变化量
  - 总和：`左右端点变化量之和`

- `复杂度估计`：**$O(n)$ ~ $O(n^2)$**


### **空间复杂度**

- $O(n)$

## 总结感悟

- 在大量调试时，可以考虑用`freopen(src, "r", stdin)`简化输入

- 边界条件一定要仔细分析！

- 初始化时，注意数组规模！有时越界的问题，很难以发现！(有些情况编译器不会报错)

- ( 日后的DSA学习一定要`注意后2条`，bug个隐藏很难找到，调试很费时间 )
