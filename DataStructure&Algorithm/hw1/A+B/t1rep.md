# 第一题

## `题目大意`

高精度乘法：计算5000位大整数相乘

## `思路分析`

题意不难理解，主要有以下两种思路：

- 模拟竖式计算
- 快速傅里叶变换（FFT）

考虑方法的熟悉程度、实现难易，本题采用第1类方法；即借助数组模拟，增长可运算的整数位宽

## `算法优化`

- 不进行压位的、纯粹的手工模拟，会造成时、空复杂度超出限制；此题压8位可以解决（减少了乘法的运算次数，降低了数组规模）
  - 领悟：最大限度地利用好每一次计算，8位*8位相比于1位乘1位，运算次数降低为1/64

- 中间变量（存储竖式计算每一行结果的2维数组）可优化为1维数组：不用中间2维数组存储，直接将每行运算结果加和至最终的res数组内；为了防止res溢出，定期对res进位
  - 领悟：最终不需要的中间结果，在程序中可以适时合并、丢弃，节约`空间`（有些情况下节约`时间`：如第4题单调队列中，丢弃无用元素、保证队列有序性，可以节约搜索时间）

## `具体实现`

- 首先以字符串的形式读入两个乘数，经过简单处理后，得到整数数组，记录每个数位上的数字

- 将整数数组8个一组，从前往后整合成longlong数组；至此，完成压位

- 开始竖式计算：两个数组均从前往后循环，模拟一位位相乘计算

- 计算结果直接用res数组存储，为防止结果溢出（因为res[] 的每一位，相当于改进前的2位数组temp[] 中一列的相加，经计算，若不进行比较与进位，res极有可能溢出）

- 竖式计算结束，开始对res[] 进行最后一次进位，方法与之前相同

- 从后往前，输出结果：除第一位外，其余不足8位的，用'0'补齐

## `时间、空间复杂度分析`

### **时间复杂度**

- $O(n^2/k^2)$ - k为压位的位数
  - 虽然理论上讲，k越大，时间复杂度越低，但是考虑到C++内置的数据类型最大字宽的限制，取k = 8能较好地均衡二者

- 其他：数组置0，需要花销不少的时间；初始版本的reset函数会占用超过50%的时间，因为temp2维数组的置0时间开销非常大
  - `经验`：日后在时间、空间要求较高的程序里，尽量减少使用2维数组

### **空间复杂度**

- $O(n)$

## 总结感悟

- 压位可以最大限度地利用好每一次计算

- 对于边界条件，特别要注意，如此题目point11 的0，若不进行特殊判断与处理，则会造成非法内存访问

- 在时间、空间要求较高的程序里，尽量减少使用2维数组