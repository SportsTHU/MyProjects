# 第三题

## `题目大意`

`编辑距离`问题：已知2字符串a、b，求解从a变成b的最少编辑次数（编辑操作：插入、删除）

## `思路分析`

`动态规划`问题，此题类似DSA课上所讲的'最长公共子串'问题。
原始方法可用二维数组实现：dp[][]数组更新分为两类：

- 第1类：a[i] == b[j]，此时的两个字符相同，dp[i][j]可直接用dp[i-1][j-1]]更新
- 第2类：a[i] != b[j]，此时需要进行一次编辑操作。具体从哪个方向更新，则由dp[i-1][j]、dp[i][j-1]中较小的确定，确定后+1得到当前的编辑代价；同理依次更新

## `算法优化`

- 空间方面
  - len(a)、len(b)<=501000，在此情况下使用`二维数组的dp`并不现实，会超出内存限制，因此可以利用`“滚动数组”`(此称呼来源于北大MOOC)，进行空间优化
  - 通过手算模拟，可以发现每次更新dp(i, j)，最多可能用到它左方、上方、左上方3个位置的元素。因此可以将二维数组优化为2个一维数组，交替更新即可

- 时间方面
  - 因为给出了修改代价的上限<=100，则可以将时间复杂度从$O(mn)$优化到$O(mk)$

## `具体实现`

- 读入两个字符串

- 申请2个一维数组，并且初始化（这里`一定要注意初始化!!`）！因为赋予初值值，直接决定了dp中其更新与否

- 进行动态规划，"滚动更新"：滚动的效果，通过对循环变量n mod2 取余来实现

- dp循环：为了降低时间复杂度，限制2重循环中的`内层循环变量j`的范围from lower to upper实现降低时间效果

- dp循环结束，输出结果（等价于原始2维数组的右下角元素）

## `时间、空间复杂度分析`

### **时间复杂度**

- $O(mk)$

### **空间复杂度**

- $O(n)$

## 总结感悟

- 动态规划等需要先进行大小比较，再确定更新的算法中：初值的赋予`非常重要, 一定要想清楚！`应该是赋予infinite small 还是 large
  - 对于此题，经过具体计算，infinite large 可以用1000代替其无穷大的效果

- 大数据规模的dp中，应采用`滚动数组`的方法，降低空间复杂度
